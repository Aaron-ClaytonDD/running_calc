{"version":3,"file":"static/js/profiler.743b402a.chunk.js","mappings":"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","sources":["../node_modules/@datadog/browser-rum/src/domain/profiling/utils/longTaskRegistry.ts","../node_modules/@datadog/browser-rum/src/domain/profiling/profilingCorrelation.ts","../node_modules/@datadog/browser-rum/src/domain/profiling/transport/transport.ts","../node_modules/@datadog/browser-rum/src/domain/profiling/profiler.ts","../node_modules/@datadog/browser-rum/src/domain/profiling/utils/getNumberOfSamples.ts"],"sourcesContent":["type PerformanceEntryStartTimeMs = number\n\n// Maps PerformanceEntry start-time to the corresponding long task id (from RUM LongTaskEvent),\n// We need this to link RUM Long Tasks with RUM Profiler stack traces\n// Given that long task takes at least 50ms and we export profile at least every 60 seconds, we can have up to 1200 entries (60s / 50ms = 1200).\nconst registry = new Map<PerformanceEntryStartTimeMs, string>()\n\n// Enable Long Task Registry only if RUM Profiler has been activated\nlet enabledTime: false | number = false\n\nexport function enableLongTaskRegistry() {\n  enabledTime = performance.now()\n}\n\nexport function disableLongTaskRegistry() {\n  enabledTime = false\n  registry.clear() // Free-up the memory\n}\n\n/**\n * Store the long task ID in the registry for the Profiler to link it with the corresponding Profile.\n */\nexport function setLongTaskId(longTaskId: string, performanceEntryStartTime: number) {\n  registry.set(performanceEntryStartTime, longTaskId)\n}\n\nexport function getLongTaskId(longTaskEntry: PerformanceEntry): string | undefined {\n  // Don't return if it's not enabled or the long task has been reported before the activation\n  if (enabledTime === false || longTaskEntry.startTime < enabledTime) {\n    return undefined\n  }\n\n  return registry.get(longTaskEntry.startTime)\n}\n\nexport function deleteLongTaskIdsBefore(collectionTime: number) {\n  if (enabledTime === false || collectionTime < enabledTime) {\n    return undefined\n  }\n\n  for (const performanceEntryStartTime of registry.keys()) {\n    if (performanceEntryStartTime < collectionTime) {\n      registry.delete(performanceEntryStartTime)\n    }\n  }\n}\n","import type { RawRumEvent } from '@datadog/browser-rum-core'\nimport { RumEventType } from '@datadog/browser-rum-core'\n\nimport { setLongTaskId } from './utils/longTaskRegistry'\n\n/**\n * Store the Long Task ID in the registry for the Profiler to link it with the corresponding Profile.\n *\n * @param rawRumEvent The Raw RUM event\n * @param startTime The start time of the event (in this case the Long Task Performance Entry start time)\n */\nexport function mayStoreLongTaskIdForProfilerCorrelation({\n  rawRumEvent,\n  startTime,\n}: {\n  rawRumEvent: RawRumEvent\n  startTime: number\n}) {\n  if (rawRumEvent.type !== RumEventType.LONG_TASK) {\n    return\n  }\n\n  const longTaskId = rawRumEvent.long_task.id\n\n  // Store longTaskId in the registry for the Profiler to link it with the corresponding Profile.\n  setLongTaskId(longTaskId, startTime)\n}\n","import { addTelemetryDebug, type EndpointBuilder, type Payload } from '@datadog/browser-core'\nimport type { RumProfilerTrace } from '../types'\nimport { getLongTaskId } from '../utils/longTaskRegistry'\n\ninterface ProfileEventAttributes {\n  application: { id: string }\n  session?: { id: string }\n  view?: { ids: string[] }\n  long_task?: { id: string[] }\n}\ninterface ProfileEvent extends ProfileEventAttributes {\n  attachments: string[]\n  start: string // ISO date\n  end: string // ISO date\n  family: 'chrome'\n  tags_profiler: string\n}\n\ntype SendProfileFunction = (\n  trace: RumProfilerTrace,\n  endpointBuilder: EndpointBuilder,\n  applicationId: string,\n  sessionId: string | undefined\n) => Promise<unknown>\n\n/**\n * Send RUM profile as JSON to public profiling intake.\n */\nconst sendProfile: SendProfileFunction = (profilerTrace, endpointBuilder, applicationId, sessionId) => {\n  const event = buildProfileEvent(profilerTrace, endpointBuilder, applicationId, sessionId)\n  const payload = buildProfilingPayload(profilerTrace, event)\n\n  // Create URL, public profiling intake.\n  const profilingIntakeURL = endpointBuilder.build('fetch', payload)\n\n  addTelemetryDebug('Sending profile to public profiling intake', { profilingIntakeURL, applicationId, sessionId })\n\n  // Send payload (event + profile as attachment).\n  return fetch(profilingIntakeURL, {\n    body: payload.data,\n    method: 'POST',\n  })\n}\n\nfunction buildProfileEvent(\n  profilerTrace: RumProfilerTrace,\n  endpointBuilder: EndpointBuilder,\n  applicationId: string,\n  sessionId: string | undefined\n): ProfileEvent {\n  const tags = endpointBuilder.tags\n  const profileAttributes = buildProfileEventAttributes(profilerTrace, applicationId, sessionId)\n  const profileEventTags = buildProfileEventTags(tags)\n\n  const start = new Date(profilerTrace.timeOrigin + profilerTrace.startTime)\n  const end = new Date(profilerTrace.timeOrigin + profilerTrace.endTime)\n\n  const profileEvent: ProfileEvent = {\n    ...profileAttributes,\n    attachments: ['wall-time.json'],\n    start: start.toISOString(),\n    end: end.toISOString(),\n    family: 'chrome',\n    tags_profiler: profileEventTags.join(','),\n  }\n\n  return profileEvent\n}\n\n/**\n * Builds tags for the Profile Event.\n * @param tags RUM tags\n * @returns Combined tags for the Profile Event.\n */\nfunction buildProfileEventTags(tags: string[]): string[] {\n  // Tags already contains the common tags for all events. (service, env, version, etc.)\n  // Here we are adding some specific-to-profiling tags.\n  const profileEventTags = tags.concat([\n    'language:javascript',\n    'runtime:chrome',\n    'family:chrome',\n    'format:json',\n    'host:browser',\n  ])\n\n  return profileEventTags\n}\n\n/**\n * Builds payload for Profiling intake. It includes the profile event and the profiler trace as attachment.\n * @param profilerTrace Profiler trace\n * @param profileEvent Profiling event.\n * @returns Payload to be sent to the intake.\n */\nfunction buildProfilingPayload(profilerTrace: RumProfilerTrace, profileEvent: ProfileEvent): Payload {\n  const profilerTraceBlob = new Blob([JSON.stringify(profilerTrace)], {\n    type: 'application/json',\n  })\n  const formData = new FormData()\n  formData.append('event', new Blob([JSON.stringify(profileEvent)], { type: 'application/json' }), 'event.json')\n  formData.append('wall-time.json', profilerTraceBlob, 'wall-time.json')\n\n  return { data: formData, bytesCount: 0 }\n}\n\n/**\n * Builds attributes for the Profile Event.\n * @param profilerTrace Profiler trace\n * @param applicationId application id.\n * @param sessionId session id.\n * @returns Additional attributes.\n */\nfunction buildProfileEventAttributes(\n  profilerTrace: RumProfilerTrace,\n  applicationId: string,\n  sessionId: string | undefined\n): ProfileEventAttributes {\n  const attributes: ProfileEventAttributes = {\n    application: {\n      id: applicationId,\n    },\n  }\n  if (sessionId) {\n    attributes.session = {\n      id: sessionId,\n    }\n  }\n  const viewIds = Array.from(new Set(profilerTrace.views.map((viewEntry) => viewEntry.viewId)))\n  if (viewIds.length) {\n    attributes.view = {\n      ids: viewIds,\n    }\n  }\n  const longTaskIds: string[] = profilerTrace.longTasks\n    .map((longTask) => getLongTaskId(longTask))\n    .filter((id) => id !== undefined)\n\n  if (longTaskIds.length) {\n    attributes.long_task = { id: longTaskIds }\n  }\n  return attributes\n}\n\nexport const transport = {\n  sendProfile,\n}\n","import {\n  addEventListener,\n  clearTimeout,\n  setTimeout,\n  DOM_EVENT,\n  monitorError,\n  display,\n  getGlobalObject,\n} from '@datadog/browser-core'\n\nimport type { LifeCycle, RumConfiguration, RumSessionManager } from '@datadog/browser-rum-core'\nimport { LifeCycleEventType, RumPerformanceEntryType, supportPerformanceTimingEvent } from '@datadog/browser-rum-core'\nimport type { RumProfilerTrace, RumProfilerInstance, Profiler, RUMProfiler, RUMProfilerConfiguration } from './types'\nimport { getNumberOfSamples } from './utils/getNumberOfSamples'\nimport { disableLongTaskRegistry, enableLongTaskRegistry, deleteLongTaskIdsBefore } from './utils/longTaskRegistry'\nimport { mayStoreLongTaskIdForProfilerCorrelation } from './profilingCorrelation'\nimport { transport } from './transport/transport'\n\nexport const DEFAULT_RUM_PROFILER_CONFIGURATION: RUMProfilerConfiguration = {\n  sampleIntervalMs: 10, // Sample stack trace every 10ms\n  collectIntervalMs: 60000, // Collect data every minute\n  minProfileDurationMs: 5000, // Require at least 5 seconds of profile data to reduce noise and cost\n  minNumberOfSamples: 50, // Require at least 50 samples (~500 ms) to report a profile to reduce noise and cost\n}\n\nexport function createRumProfiler(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  session: RumSessionManager,\n  profilerConfiguration: RUMProfilerConfiguration = DEFAULT_RUM_PROFILER_CONFIGURATION\n): RUMProfiler {\n  const isLongAnimationFrameEnabled = supportPerformanceTimingEvent(RumPerformanceEntryType.LONG_ANIMATION_FRAME)\n\n  let instance: RumProfilerInstance = { state: 'stopped' }\n\n  function start(viewId: string | undefined): void {\n    if (instance.state === 'running') {\n      return\n    }\n\n    // Add initial view\n    collectViewEntry(viewId)\n\n    // Start profiler instance\n    startNextProfilerInstance()\n  }\n\n  async function stop() {\n    // Stop current profiler instance\n    await stopProfilerInstance('stopped')\n\n    // Disable Long Task Registry as we no longer need to correlate them with RUM\n    disableLongTaskRegistry()\n  }\n\n  /**\n   * Whenever a new Profiler instance is started, we need to add event listeners to surroundings (RUM Events, Long Tasks, etc) to enrich the Profiler data.\n   * If the instance is already running, we can keep the same event listeners.\n   */\n  function addEventListeners(existingInstance: RumProfilerInstance) {\n    if (existingInstance.state === 'running') {\n      // Instance is already running, so we can keep same event listeners.\n      return {\n        cleanupTasks: existingInstance.cleanupTasks,\n        observer: existingInstance.observer,\n      }\n    }\n\n    // Store clean-up tasks for this instance (tasks to be executed when the Profiler is stopped or paused.)\n    const cleanupTasks = []\n    let observer: PerformanceObserver | undefined\n\n    // Register everything linked to Long Tasks correlations with RUM, when enabled.\n    if (configuration.trackLongTasks) {\n      // Setup event listeners, and since we only listen to Long Tasks for now, we activate the Performance Observer only when they are tracked.\n      observer = new PerformanceObserver(handlePerformance)\n      observer.observe({\n        entryTypes: [getLongTaskEntryType()],\n      })\n\n      // Whenever an Event is collected, when it's a Long Task, we may store the long task id for profiler correlation.\n      const rawEventCollectedSubscription = lifeCycle.subscribe(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, (data) => {\n        mayStoreLongTaskIdForProfilerCorrelation(data)\n      })\n\n      // Enable Long Task registry so we can correlate them with RUM\n      enableLongTaskRegistry()\n\n      cleanupTasks.push(() => observer?.disconnect())\n      cleanupTasks.push(rawEventCollectedSubscription.unsubscribe)\n    }\n\n    cleanupTasks.push(\n      addEventListener(configuration, window, DOM_EVENT.VISIBILITY_CHANGE, handleVisibilityChange).stop,\n      addEventListener(configuration, window, DOM_EVENT.BEFORE_UNLOAD, handleBeforeUnload).stop\n    )\n\n    // Whenever the View is updated, we add a views entry to the profiler instance.\n    const viewUpdatedSubscription = lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, (view) => {\n      collectViewEntry(view.id)\n    })\n    cleanupTasks.push(viewUpdatedSubscription.unsubscribe)\n\n    return {\n      cleanupTasks,\n      observer,\n    }\n  }\n\n  function startNextProfilerInstance(): void {\n    // These APIs might be unavailable in some browsers\n    const globalThisProfiler: Profiler | undefined = getGlobalObject<any>().Profiler\n\n    if (!globalThisProfiler) {\n      throw new Error('RUM Profiler is not supported in this browser.')\n    }\n\n    // Don't wait for data collection to start next instance\n    collectProfilerInstance().catch(monitorError)\n\n    const { cleanupTasks, observer } = addEventListeners(instance)\n\n    let profiler: Profiler\n    try {\n      // We have to create new Profiler each time we start a new instance\n      profiler = new globalThisProfiler({\n        sampleInterval: profilerConfiguration.sampleIntervalMs,\n        // Keep buffer size at 1.5 times of minimum required to collect data for a profiling instance\n        maxBufferSize: Math.round(\n          (profilerConfiguration.collectIntervalMs * 1.5) / profilerConfiguration.sampleIntervalMs\n        ),\n      })\n    } catch (e) {\n      // If we fail to create a profiler, it's likely due to the missing Response Header (`js-profiling`) that is required to enable the profiler.\n      // We should suggest the user to enable the Response Header in their server configuration.\n      display.warn(\n        '[DD_RUM] Profiler startup failed. Ensure your server includes the `Document-Policy: js-profiling` response header when serving HTML pages.',\n        e\n      )\n      return\n    }\n\n    // Kick-off the new instance\n    instance = {\n      state: 'running',\n      startTime: performance.now(),\n      profiler,\n      timeoutId: setTimeout(startNextProfilerInstance, profilerConfiguration.collectIntervalMs),\n      longTasks: [],\n      views: [],\n      cleanupTasks,\n      observer,\n    }\n\n    // Add event handler case we overflow the buffer\n    profiler.addEventListener('samplebufferfull', handleSampleBufferFull)\n  }\n\n  async function collectProfilerInstance() {\n    if (instance.state !== 'running') {\n      return\n    }\n\n    // Empty the performance observer buffer\n    handleLongTaskEntries(instance.observer?.takeRecords() ?? [])\n\n    // Cleanup instance\n    clearTimeout(instance.timeoutId)\n    instance.profiler.removeEventListener('samplebufferfull', handleSampleBufferFull)\n\n    // Store instance data snapshot in local variables to use in async callback\n    const { startTime, longTasks, views } = instance\n\n    // Capturing when we stop the profiler so we use this time as a reference to clean-up long task registry, eg. remove the long tasks that we collected already\n    const collectTime = performance.now()\n\n    // Stop current profiler to get trace\n    await instance.profiler\n      .stop()\n      .then((trace) => {\n        const endTime = performance.now()\n\n        if (endTime - startTime < profilerConfiguration.minProfileDurationMs) {\n          // Skip very short profiles to reduce noise and cost\n          return\n        }\n\n        if (getNumberOfSamples(trace.samples) < profilerConfiguration.minNumberOfSamples) {\n          // Skip idle profiles to reduce noise and cost\n          return\n        }\n\n        handleProfilerTrace(\n          // Enrich trace with time and instance data\n          Object.assign(trace, {\n            startTime,\n            endTime,\n            timeOrigin: performance.timeOrigin,\n            longTasks,\n            views,\n            sampleInterval: profilerConfiguration.sampleIntervalMs,\n          })\n        )\n\n        // Clear long task registry, remove entries that we collected already (eg. avoid slowly growing memory usage by keeping outdated entries)\n        deleteLongTaskIdsBefore(collectTime)\n      })\n      .catch(monitorError)\n  }\n\n  async function stopProfilerInstance(nextState: 'paused' | 'stopped') {\n    if (instance.state !== 'running') {\n      return\n    }\n\n    // Cleanup tasks\n    instance.cleanupTasks.forEach((cleanupTask) => cleanupTask())\n\n    await collectProfilerInstance()\n\n    instance = { state: nextState }\n  }\n\n  function collectViewEntry(viewId: string | undefined): void {\n    if (instance.state !== 'running') {\n      return\n    }\n\n    // Add entry to views\n    instance.views.push({\n      startTime: performance.now(),\n      viewId: viewId || '',\n    })\n  }\n\n  function handleProfilerTrace(trace: RumProfilerTrace): void {\n    // Find current session to assign it to the Profile.\n    const sessionId = session.findTrackedSession()?.id\n\n    // Send JSON Profile to intake.\n    transport\n      .sendProfile(trace, configuration.profilingEndpointBuilder, configuration.applicationId, sessionId)\n      .catch(monitorError)\n  }\n\n  function handleSampleBufferFull(): void {\n    startNextProfilerInstance()\n  }\n\n  function handlePerformance(list: PerformanceObserverEntryList): void {\n    handleLongTaskEntries(list.getEntries())\n  }\n\n  function handleLongTaskEntries(entries: PerformanceEntryList): void {\n    if (instance.state !== 'running') {\n      return\n    }\n\n    for (const entry of entries) {\n      if (entry.duration < profilerConfiguration.sampleIntervalMs) {\n        // Skip entries shorter than sample interval to reduce noise and size of profile\n        continue\n      }\n\n      instance.longTasks.push(entry)\n    }\n  }\n\n  function handleVisibilityChange(): void {\n    if (document.visibilityState === 'hidden' && instance.state === 'running') {\n      // Pause when tab is hidden. We use paused state to distinguish between\n      // paused by visibility change and stopped by user.\n      // If profiler is paused by the visibility change, we should resume when\n      // tab becomes visible again. That's not the case when user stops the profiler.\n      stopProfilerInstance('paused').catch(monitorError)\n    } else if (document.visibilityState === 'visible' && instance.state === 'paused') {\n      // Resume when tab becomes visible again\n      startNextProfilerInstance()\n    }\n  }\n\n  function handleBeforeUnload(): void {\n    // `unload` can in some cases be triggered while the page is still active (link to a different protocol like mailto:).\n    // We can immediately flush (by starting a new profiler instance) to make sure we receive the data, and at the same time keep the profiler active.\n    // In case of the regular unload, the profiler will be shut down anyway.\n    startNextProfilerInstance()\n  }\n\n  function getLongTaskEntryType(): 'long-animation-frame' | 'longtask' {\n    return isLongAnimationFrameEnabled ? 'long-animation-frame' : 'longtask'\n  }\n\n  function isStopped() {\n    return instance.state === 'stopped'\n  }\n\n  function isStarted() {\n    return instance.state === 'running'\n  }\n\n  return { start, stop, isStopped, isStarted }\n}\n","import type { ProfilerSample } from '../types'\n\n/**\n * Counts number of samples when the thread was not idle (stackId is defined)\n * @param samples Array of collected samples\n * @returns Number of samples\n */\nexport function getNumberOfSamples(samples: ProfilerSample[]): number {\n  let numberOfSamples = 0\n  for (const sample of samples) {\n    if (sample.stackId !== undefined) {\n      numberOfSamples++\n    }\n  }\n  return numberOfSamples\n}\n"],"names":["registry","Map","enabledTime","mayStoreLongTaskIdForProfilerCorrelation","_ref","rawRumEvent","startTime","type","longTaskId","performanceEntryStartTime","set","setLongTaskId","long_task","id","transport","sendProfile","profilerTrace","endpointBuilder","applicationId","sessionId","event","tags","profileAttributes","attributes","application","session","viewIds","Array","from","Set","views","map","viewEntry","viewId","length","view","ids","longTaskIds","longTasks","longTask","longTaskEntry","get","getLongTaskId","filter","undefined","buildProfileEventAttributes","profileEventTags","concat","buildProfileEventTags","start","Date","timeOrigin","end","endTime","attachments","toISOString","family","tags_profiler","join","buildProfileEvent","payload","profileEvent","profilerTraceBlob","Blob","JSON","stringify","formData","FormData","append","data","bytesCount","buildProfilingPayload","profilingIntakeURL","build","addTelemetryDebug","fetch","body","method","DEFAULT_RUM_PROFILER_CONFIGURATION","sampleIntervalMs","collectIntervalMs","minProfileDurationMs","minNumberOfSamples","createRumProfiler","configuration","lifeCycle","profilerConfiguration","arguments","isLongAnimationFrameEnabled","supportPerformanceTimingEvent","RumPerformanceEntryType","LONG_ANIMATION_FRAME","instance","state","addEventListeners","existingInstance","cleanupTasks","observer","trackLongTasks","PerformanceObserver","handlePerformance","observe","entryTypes","rawEventCollectedSubscription","subscribe","performance","now","push","disconnect","unsubscribe","addEventListener","window","handleVisibilityChange","stop","handleBeforeUnload","viewUpdatedSubscription","collectViewEntry","startNextProfilerInstance","globalThisProfiler","getGlobalObject","Profiler","Error","collectProfilerInstance","catch","monitorError","profiler","sampleInterval","maxBufferSize","Math","round","e","display","warn","timeoutId","setTimeout","handleSampleBufferFull","async","handleLongTaskEntries","_b","_a","takeRecords","clearTimeout","removeEventListener","collectTime","then","trace","samples","numberOfSamples","sample","stackId","getNumberOfSamples","findTrackedSession","profilingEndpointBuilder","handleProfilerTrace","Object","assign","collectionTime","keys","delete","deleteLongTaskIdsBefore","stopProfilerInstance","nextState","forEach","cleanupTask","list","getEntries","entries","entry","duration","document","visibilityState","clear","isStopped","isStarted"],"sourceRoot":""}